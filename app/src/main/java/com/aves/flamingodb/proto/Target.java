// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/firebase/firestore/proto/target.proto

package com.aves.flamingodb.proto;

/**
 * <pre>
 * A Target is a long-lived data structure representing a resumable listen on a
 * particular user query. While the query describes what to listen to, the
 * Target records data about when the results were last updated and enough
 * information to be able to resume listening later.
 * </pre>
 *
 * Protobuf type {@code firestore.client.Target}
 */
public  final class Target extends
    com.google.protobuf.GeneratedMessageLite<
        Target, Target.Builder> implements
    // @@protoc_insertion_point(message_implements:firestore.client.Target)
    TargetOrBuilder {
  private Target() {
    resumeToken_ = com.google.protobuf.ByteString.EMPTY;
  }
  private int targetTypeCase_ = 0;
  private Object targetType_;
  public enum TargetTypeCase {
    QUERY(5),
    DOCUMENTS(6),
    TARGETTYPE_NOT_SET(0);
    private final int value;
    private TargetTypeCase(int value) {
      this.value = value;
    }
    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @Deprecated
    public static TargetTypeCase valueOf(int value) {
      return forNumber(value);
    }

    public static TargetTypeCase forNumber(int value) {
      switch (value) {
        case 5: return QUERY;
        case 6: return DOCUMENTS;
        case 0: return TARGETTYPE_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  @Override
  public TargetTypeCase
  getTargetTypeCase() {
    return TargetTypeCase.forNumber(
        targetTypeCase_);
  }

  private void clearTargetType() {
    targetTypeCase_ = 0;
    targetType_ = null;
  }

  public static final int TARGET_ID_FIELD_NUMBER = 1;
  private int targetId_;
  /**
   * <pre>
   * An auto-generated sequential numeric identifier for the target. This
   * serves as the identity of the target, and once assigned never changes.
   * </pre>
   *
   * <code>int32 target_id = 1;</code>
   * @return The targetId.
   */
  @Override
  public int getTargetId() {
    return targetId_;
  }
  /**
   * <pre>
   * An auto-generated sequential numeric identifier for the target. This
   * serves as the identity of the target, and once assigned never changes.
   * </pre>
   *
   * <code>int32 target_id = 1;</code>
   * @param value The targetId to set.
   */
  private void setTargetId(int value) {
    
    targetId_ = value;
  }
  /**
   * <pre>
   * An auto-generated sequential numeric identifier for the target. This
   * serves as the identity of the target, and once assigned never changes.
   * </pre>
   *
   * <code>int32 target_id = 1;</code>
   */
  private void clearTargetId() {
    
    targetId_ = 0;
  }

  public static final int SNAPSHOT_VERSION_FIELD_NUMBER = 2;
  private com.google.protobuf.Timestamp snapshotVersion_;
  /**
   * <pre>
   * The last snapshot version received from the Watch Service for this target.
   * This is the same value as TargetChange.read_time
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
   * </pre>
   *
   * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
   */
  @Override
  public boolean hasSnapshotVersion() {
    return snapshotVersion_ != null;
  }
  /**
   * <pre>
   * The last snapshot version received from the Watch Service for this target.
   * This is the same value as TargetChange.read_time
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
   * </pre>
   *
   * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
   */
  @Override
  public com.google.protobuf.Timestamp getSnapshotVersion() {
    return snapshotVersion_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : snapshotVersion_;
  }
  /**
   * <pre>
   * The last snapshot version received from the Watch Service for this target.
   * This is the same value as TargetChange.read_time
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
   * </pre>
   *
   * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
   */
  private void setSnapshotVersion(com.google.protobuf.Timestamp value) {
    value.getClass();
  snapshotVersion_ = value;
    
    }
  /**
   * <pre>
   * The last snapshot version received from the Watch Service for this target.
   * This is the same value as TargetChange.read_time
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
   * </pre>
   *
   * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
   */
  @SuppressWarnings({"ReferenceEquality"})
  private void mergeSnapshotVersion(com.google.protobuf.Timestamp value) {
    value.getClass();
  if (snapshotVersion_ != null &&
        snapshotVersion_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      snapshotVersion_ =
        com.google.protobuf.Timestamp.newBuilder(snapshotVersion_).mergeFrom(value).buildPartial();
    } else {
      snapshotVersion_ = value;
    }
    
  }
  /**
   * <pre>
   * The last snapshot version received from the Watch Service for this target.
   * This is the same value as TargetChange.read_time
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
   * </pre>
   *
   * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
   */
  private void clearSnapshotVersion() {  snapshotVersion_ = null;
    
  }

  public static final int RESUME_TOKEN_FIELD_NUMBER = 3;
  private com.google.protobuf.ByteString resumeToken_;
  /**
   * <pre>
   * An opaque, server-assigned token that allows watching a query to be
   * resumed after disconnecting without retransmitting all the data that
   * matches the query. The resume token essentially identifies a point in
   * time from which the server should resume sending results.
   * This is related to the snapshot_version in that the resume_token
   * effectively also encodes that value, but the resume_token is opaque and
   * sometimes encodes additional information.
   * A consequence of this is that the resume_token should be used when asking
   * the server to reason about where this client is in the watch stream, but
   * the client should use the snapshot_version for its own purposes.
   * This is the same value as TargetChange.resume_token
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L723
   * </pre>
   *
   * <code>bytes resume_token = 3;</code>
   * @return The resumeToken.
   */
  @Override
  public com.google.protobuf.ByteString getResumeToken() {
    return resumeToken_;
  }
  /**
   * <pre>
   * An opaque, server-assigned token that allows watching a query to be
   * resumed after disconnecting without retransmitting all the data that
   * matches the query. The resume token essentially identifies a point in
   * time from which the server should resume sending results.
   * This is related to the snapshot_version in that the resume_token
   * effectively also encodes that value, but the resume_token is opaque and
   * sometimes encodes additional information.
   * A consequence of this is that the resume_token should be used when asking
   * the server to reason about where this client is in the watch stream, but
   * the client should use the snapshot_version for its own purposes.
   * This is the same value as TargetChange.resume_token
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L723
   * </pre>
   *
   * <code>bytes resume_token = 3;</code>
   * @param value The resumeToken to set.
   */
  private void setResumeToken(com.google.protobuf.ByteString value) {
    Class<?> valueClass = value.getClass();
  
    resumeToken_ = value;
  }
  /**
   * <pre>
   * An opaque, server-assigned token that allows watching a query to be
   * resumed after disconnecting without retransmitting all the data that
   * matches the query. The resume token essentially identifies a point in
   * time from which the server should resume sending results.
   * This is related to the snapshot_version in that the resume_token
   * effectively also encodes that value, but the resume_token is opaque and
   * sometimes encodes additional information.
   * A consequence of this is that the resume_token should be used when asking
   * the server to reason about where this client is in the watch stream, but
   * the client should use the snapshot_version for its own purposes.
   * This is the same value as TargetChange.resume_token
   * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L723
   * </pre>
   *
   * <code>bytes resume_token = 3;</code>
   */
  private void clearResumeToken() {
    
    resumeToken_ = getDefaultInstance().getResumeToken();
  }

  public static final int LAST_LISTEN_SEQUENCE_NUMBER_FIELD_NUMBER = 4;
  private long lastListenSequenceNumber_;
  /**
   * <pre>
   * A sequence number representing the last time this query was listened to,
   * used for garbage collection purposes.
   * Conventionally this would be a timestamp value, but device-local clocks
   * are unreliable and they must be able to create new listens even while
   * disconnected. Instead this should be a monotonically increasing number
   * that's incremented on each listen call.
   * This is different from the target_id since the target_id is an immutable
   * identifier assigned to the Target on first use while
   * last_listen_sequence_number is updated every time the query is listened
   * to.
   * </pre>
   *
   * <code>int64 last_listen_sequence_number = 4;</code>
   * @return The lastListenSequenceNumber.
   */
  @Override
  public long getLastListenSequenceNumber() {
    return lastListenSequenceNumber_;
  }
  /**
   * <pre>
   * A sequence number representing the last time this query was listened to,
   * used for garbage collection purposes.
   * Conventionally this would be a timestamp value, but device-local clocks
   * are unreliable and they must be able to create new listens even while
   * disconnected. Instead this should be a monotonically increasing number
   * that's incremented on each listen call.
   * This is different from the target_id since the target_id is an immutable
   * identifier assigned to the Target on first use while
   * last_listen_sequence_number is updated every time the query is listened
   * to.
   * </pre>
   *
   * <code>int64 last_listen_sequence_number = 4;</code>
   * @param value The lastListenSequenceNumber to set.
   */
  private void setLastListenSequenceNumber(long value) {
    
    lastListenSequenceNumber_ = value;
  }
  /**
   * <pre>
   * A sequence number representing the last time this query was listened to,
   * used for garbage collection purposes.
   * Conventionally this would be a timestamp value, but device-local clocks
   * are unreliable and they must be able to create new listens even while
   * disconnected. Instead this should be a monotonically increasing number
   * that's incremented on each listen call.
   * This is different from the target_id since the target_id is an immutable
   * identifier assigned to the Target on first use while
   * last_listen_sequence_number is updated every time the query is listened
   * to.
   * </pre>
   *
   * <code>int64 last_listen_sequence_number = 4;</code>
   */
  private void clearLastListenSequenceNumber() {
    
    lastListenSequenceNumber_ = 0L;
  }

  public static final int QUERY_FIELD_NUMBER = 5;
  /**
   * <pre>
   * A target specified by a query.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
   */
  @Override
  public boolean hasQuery() {
    return targetTypeCase_ == 5;
  }
  /**
   * <pre>
   * A target specified by a query.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
   */
  @Override
  public com.google.firestore.v1.Target.QueryTarget getQuery() {
    if (targetTypeCase_ == 5) {
       return (com.google.firestore.v1.Target.QueryTarget) targetType_;
    }
    return com.google.firestore.v1.Target.QueryTarget.getDefaultInstance();
  }
  /**
   * <pre>
   * A target specified by a query.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
   */
  private void setQuery(com.google.firestore.v1.Target.QueryTarget value) {
    value.getClass();
  targetType_ = value;
    targetTypeCase_ = 5;
  }
  /**
   * <pre>
   * A target specified by a query.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
   */
  private void mergeQuery(com.google.firestore.v1.Target.QueryTarget value) {
    value.getClass();
  if (targetTypeCase_ == 5 &&
        targetType_ != com.google.firestore.v1.Target.QueryTarget.getDefaultInstance()) {
      targetType_ = com.google.firestore.v1.Target.QueryTarget.newBuilder((com.google.firestore.v1.Target.QueryTarget) targetType_)
          .mergeFrom(value).buildPartial();
    } else {
      targetType_ = value;
    }
    targetTypeCase_ = 5;
  }
  /**
   * <pre>
   * A target specified by a query.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
   */
  private void clearQuery() {
    if (targetTypeCase_ == 5) {
      targetTypeCase_ = 0;
      targetType_ = null;
    }
  }

  public static final int DOCUMENTS_FIELD_NUMBER = 6;
  /**
   * <pre>
   * A target specified by a set of document names.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
   */
  @Override
  public boolean hasDocuments() {
    return targetTypeCase_ == 6;
  }
  /**
   * <pre>
   * A target specified by a set of document names.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
   */
  @Override
  public com.google.firestore.v1.Target.DocumentsTarget getDocuments() {
    if (targetTypeCase_ == 6) {
       return (com.google.firestore.v1.Target.DocumentsTarget) targetType_;
    }
    return com.google.firestore.v1.Target.DocumentsTarget.getDefaultInstance();
  }
  /**
   * <pre>
   * A target specified by a set of document names.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
   */
  private void setDocuments(com.google.firestore.v1.Target.DocumentsTarget value) {
    value.getClass();
  targetType_ = value;
    targetTypeCase_ = 6;
  }
  /**
   * <pre>
   * A target specified by a set of document names.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
   */
  private void mergeDocuments(com.google.firestore.v1.Target.DocumentsTarget value) {
    value.getClass();
  if (targetTypeCase_ == 6 &&
        targetType_ != com.google.firestore.v1.Target.DocumentsTarget.getDefaultInstance()) {
      targetType_ = com.google.firestore.v1.Target.DocumentsTarget.newBuilder((com.google.firestore.v1.Target.DocumentsTarget) targetType_)
          .mergeFrom(value).buildPartial();
    } else {
      targetType_ = value;
    }
    targetTypeCase_ = 6;
  }
  /**
   * <pre>
   * A target specified by a set of document names.
   * </pre>
   *
   * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
   */
  private void clearDocuments() {
    if (targetTypeCase_ == 6) {
      targetTypeCase_ = 0;
      targetType_ = null;
    }
  }

  public static final int LAST_LIMBO_FREE_SNAPSHOT_VERSION_FIELD_NUMBER = 7;
  private com.google.protobuf.Timestamp lastLimboFreeSnapshotVersion_;
  /**
   * <pre>
   * Denotes the maximum snapshot version at which the associated query view
   * contained no limbo documents.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
   */
  @Override
  public boolean hasLastLimboFreeSnapshotVersion() {
    return lastLimboFreeSnapshotVersion_ != null;
  }
  /**
   * <pre>
   * Denotes the maximum snapshot version at which the associated query view
   * contained no limbo documents.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
   */
  @Override
  public com.google.protobuf.Timestamp getLastLimboFreeSnapshotVersion() {
    return lastLimboFreeSnapshotVersion_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : lastLimboFreeSnapshotVersion_;
  }
  /**
   * <pre>
   * Denotes the maximum snapshot version at which the associated query view
   * contained no limbo documents.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
   */
  private void setLastLimboFreeSnapshotVersion(com.google.protobuf.Timestamp value) {
    value.getClass();
  lastLimboFreeSnapshotVersion_ = value;
    
    }
  /**
   * <pre>
   * Denotes the maximum snapshot version at which the associated query view
   * contained no limbo documents.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
   */
  @SuppressWarnings({"ReferenceEquality"})
  private void mergeLastLimboFreeSnapshotVersion(com.google.protobuf.Timestamp value) {
    value.getClass();
  if (lastLimboFreeSnapshotVersion_ != null &&
        lastLimboFreeSnapshotVersion_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      lastLimboFreeSnapshotVersion_ =
        com.google.protobuf.Timestamp.newBuilder(lastLimboFreeSnapshotVersion_).mergeFrom(value).buildPartial();
    } else {
      lastLimboFreeSnapshotVersion_ = value;
    }
    
  }
  /**
   * <pre>
   * Denotes the maximum snapshot version at which the associated query view
   * contained no limbo documents.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
   */
  private void clearLastLimboFreeSnapshotVersion() {  lastLimboFreeSnapshotVersion_ = null;
    
  }

  public static com.google.firebase.firestore.proto.Target parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.firebase.firestore.proto.Target parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.google.firebase.firestore.proto.Target parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.firebase.firestore.proto.Target parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(com.google.firebase.firestore.proto.Target prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   * A Target is a long-lived data structure representing a resumable listen on a
   * particular user query. While the query describes what to listen to, the
   * Target records data about when the results were last updated and enough
   * information to be able to resume listening later.
   * </pre>
   *
   * Protobuf type {@code firestore.client.Target}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.firebase.firestore.proto.Target, Builder> implements
      // @@protoc_insertion_point(builder_implements:firestore.client.Target)
      com.google.firebase.firestore.proto.TargetOrBuilder {
    // Construct using com.google.firebase.firestore.proto.Target.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }

    @Override
    public TargetTypeCase
        getTargetTypeCase() {
      return instance.getTargetTypeCase();
    }

    public Builder clearTargetType() {
      copyOnWrite();
      instance.clearTargetType();
      return this;
    }


    /**
     * <pre>
     * An auto-generated sequential numeric identifier for the target. This
     * serves as the identity of the target, and once assigned never changes.
     * </pre>
     *
     * <code>int32 target_id = 1;</code>
     * @return The targetId.
     */
    @Override
    public int getTargetId() {
      return instance.getTargetId();
    }
    /**
     * <pre>
     * An auto-generated sequential numeric identifier for the target. This
     * serves as the identity of the target, and once assigned never changes.
     * </pre>
     *
     * <code>int32 target_id = 1;</code>
     * @param value The targetId to set.
     * @return This builder for chaining.
     */
    public Builder setTargetId(int value) {
      copyOnWrite();
      instance.setTargetId(value);
      return this;
    }
    /**
     * <pre>
     * An auto-generated sequential numeric identifier for the target. This
     * serves as the identity of the target, and once assigned never changes.
     * </pre>
     *
     * <code>int32 target_id = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearTargetId() {
      copyOnWrite();
      instance.clearTargetId();
      return this;
    }

    /**
     * <pre>
     * The last snapshot version received from the Watch Service for this target.
     * This is the same value as TargetChange.read_time
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
     * </pre>
     *
     * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
     */
    @Override
    public boolean hasSnapshotVersion() {
      return instance.hasSnapshotVersion();
    }
    /**
     * <pre>
     * The last snapshot version received from the Watch Service for this target.
     * This is the same value as TargetChange.read_time
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
     * </pre>
     *
     * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
     */
    @Override
    public com.google.protobuf.Timestamp getSnapshotVersion() {
      return instance.getSnapshotVersion();
    }
    /**
     * <pre>
     * The last snapshot version received from the Watch Service for this target.
     * This is the same value as TargetChange.read_time
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
     * </pre>
     *
     * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
     */
    public Builder setSnapshotVersion(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setSnapshotVersion(value);
      return this;
      }
    /**
     * <pre>
     * The last snapshot version received from the Watch Service for this target.
     * This is the same value as TargetChange.read_time
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
     * </pre>
     *
     * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
     */
    public Builder setSnapshotVersion(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setSnapshotVersion(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * The last snapshot version received from the Watch Service for this target.
     * This is the same value as TargetChange.read_time
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
     * </pre>
     *
     * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
     */
    public Builder mergeSnapshotVersion(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeSnapshotVersion(value);
      return this;
    }
    /**
     * <pre>
     * The last snapshot version received from the Watch Service for this target.
     * This is the same value as TargetChange.read_time
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L735
     * </pre>
     *
     * <code>.google.protobuf.Timestamp snapshot_version = 2;</code>
     */
    public Builder clearSnapshotVersion() {  copyOnWrite();
      instance.clearSnapshotVersion();
      return this;
    }

    /**
     * <pre>
     * An opaque, server-assigned token that allows watching a query to be
     * resumed after disconnecting without retransmitting all the data that
     * matches the query. The resume token essentially identifies a point in
     * time from which the server should resume sending results.
     * This is related to the snapshot_version in that the resume_token
     * effectively also encodes that value, but the resume_token is opaque and
     * sometimes encodes additional information.
     * A consequence of this is that the resume_token should be used when asking
     * the server to reason about where this client is in the watch stream, but
     * the client should use the snapshot_version for its own purposes.
     * This is the same value as TargetChange.resume_token
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L723
     * </pre>
     *
     * <code>bytes resume_token = 3;</code>
     * @return The resumeToken.
     */
    @Override
    public com.google.protobuf.ByteString getResumeToken() {
      return instance.getResumeToken();
    }
    /**
     * <pre>
     * An opaque, server-assigned token that allows watching a query to be
     * resumed after disconnecting without retransmitting all the data that
     * matches the query. The resume token essentially identifies a point in
     * time from which the server should resume sending results.
     * This is related to the snapshot_version in that the resume_token
     * effectively also encodes that value, but the resume_token is opaque and
     * sometimes encodes additional information.
     * A consequence of this is that the resume_token should be used when asking
     * the server to reason about where this client is in the watch stream, but
     * the client should use the snapshot_version for its own purposes.
     * This is the same value as TargetChange.resume_token
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L723
     * </pre>
     *
     * <code>bytes resume_token = 3;</code>
     * @param value The resumeToken to set.
     * @return This builder for chaining.
     */
    public Builder setResumeToken(com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setResumeToken(value);
      return this;
    }
    /**
     * <pre>
     * An opaque, server-assigned token that allows watching a query to be
     * resumed after disconnecting without retransmitting all the data that
     * matches the query. The resume token essentially identifies a point in
     * time from which the server should resume sending results.
     * This is related to the snapshot_version in that the resume_token
     * effectively also encodes that value, but the resume_token is opaque and
     * sometimes encodes additional information.
     * A consequence of this is that the resume_token should be used when asking
     * the server to reason about where this client is in the watch stream, but
     * the client should use the snapshot_version for its own purposes.
     * This is the same value as TargetChange.resume_token
     * https://github.com/googleapis/googleapis/blob/master/google/firestore/v1/firestore.proto#L723
     * </pre>
     *
     * <code>bytes resume_token = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearResumeToken() {
      copyOnWrite();
      instance.clearResumeToken();
      return this;
    }

    /**
     * <pre>
     * A sequence number representing the last time this query was listened to,
     * used for garbage collection purposes.
     * Conventionally this would be a timestamp value, but device-local clocks
     * are unreliable and they must be able to create new listens even while
     * disconnected. Instead this should be a monotonically increasing number
     * that's incremented on each listen call.
     * This is different from the target_id since the target_id is an immutable
     * identifier assigned to the Target on first use while
     * last_listen_sequence_number is updated every time the query is listened
     * to.
     * </pre>
     *
     * <code>int64 last_listen_sequence_number = 4;</code>
     * @return The lastListenSequenceNumber.
     */
    @Override
    public long getLastListenSequenceNumber() {
      return instance.getLastListenSequenceNumber();
    }
    /**
     * <pre>
     * A sequence number representing the last time this query was listened to,
     * used for garbage collection purposes.
     * Conventionally this would be a timestamp value, but device-local clocks
     * are unreliable and they must be able to create new listens even while
     * disconnected. Instead this should be a monotonically increasing number
     * that's incremented on each listen call.
     * This is different from the target_id since the target_id is an immutable
     * identifier assigned to the Target on first use while
     * last_listen_sequence_number is updated every time the query is listened
     * to.
     * </pre>
     *
     * <code>int64 last_listen_sequence_number = 4;</code>
     * @param value The lastListenSequenceNumber to set.
     * @return This builder for chaining.
     */
    public Builder setLastListenSequenceNumber(long value) {
      copyOnWrite();
      instance.setLastListenSequenceNumber(value);
      return this;
    }
    /**
     * <pre>
     * A sequence number representing the last time this query was listened to,
     * used for garbage collection purposes.
     * Conventionally this would be a timestamp value, but device-local clocks
     * are unreliable and they must be able to create new listens even while
     * disconnected. Instead this should be a monotonically increasing number
     * that's incremented on each listen call.
     * This is different from the target_id since the target_id is an immutable
     * identifier assigned to the Target on first use while
     * last_listen_sequence_number is updated every time the query is listened
     * to.
     * </pre>
     *
     * <code>int64 last_listen_sequence_number = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearLastListenSequenceNumber() {
      copyOnWrite();
      instance.clearLastListenSequenceNumber();
      return this;
    }

    /**
     * <pre>
     * A target specified by a query.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
     */
    @Override
    public boolean hasQuery() {
      return instance.hasQuery();
    }
    /**
     * <pre>
     * A target specified by a query.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
     */
    @Override
    public com.google.firestore.v1.Target.QueryTarget getQuery() {
      return instance.getQuery();
    }
    /**
     * <pre>
     * A target specified by a query.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
     */
    public Builder setQuery(com.google.firestore.v1.Target.QueryTarget value) {
      copyOnWrite();
      instance.setQuery(value);
      return this;
    }
    /**
     * <pre>
     * A target specified by a query.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
     */
    public Builder setQuery(
        com.google.firestore.v1.Target.QueryTarget.Builder builderForValue) {
      copyOnWrite();
      instance.setQuery(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * A target specified by a query.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
     */
    public Builder mergeQuery(com.google.firestore.v1.Target.QueryTarget value) {
      copyOnWrite();
      instance.mergeQuery(value);
      return this;
    }
    /**
     * <pre>
     * A target specified by a query.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.QueryTarget query = 5;</code>
     */
    public Builder clearQuery() {
      copyOnWrite();
      instance.clearQuery();
      return this;
    }

    /**
     * <pre>
     * A target specified by a set of document names.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
     */
    @Override
    public boolean hasDocuments() {
      return instance.hasDocuments();
    }
    /**
     * <pre>
     * A target specified by a set of document names.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
     */
    @Override
    public com.google.firestore.v1.Target.DocumentsTarget getDocuments() {
      return instance.getDocuments();
    }
    /**
     * <pre>
     * A target specified by a set of document names.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
     */
    public Builder setDocuments(com.google.firestore.v1.Target.DocumentsTarget value) {
      copyOnWrite();
      instance.setDocuments(value);
      return this;
    }
    /**
     * <pre>
     * A target specified by a set of document names.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
     */
    public Builder setDocuments(
        com.google.firestore.v1.Target.DocumentsTarget.Builder builderForValue) {
      copyOnWrite();
      instance.setDocuments(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * A target specified by a set of document names.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
     */
    public Builder mergeDocuments(com.google.firestore.v1.Target.DocumentsTarget value) {
      copyOnWrite();
      instance.mergeDocuments(value);
      return this;
    }
    /**
     * <pre>
     * A target specified by a set of document names.
     * </pre>
     *
     * <code>.google.firestore.v1.Target.DocumentsTarget documents = 6;</code>
     */
    public Builder clearDocuments() {
      copyOnWrite();
      instance.clearDocuments();
      return this;
    }

    /**
     * <pre>
     * Denotes the maximum snapshot version at which the associated query view
     * contained no limbo documents.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
     */
    @Override
    public boolean hasLastLimboFreeSnapshotVersion() {
      return instance.hasLastLimboFreeSnapshotVersion();
    }
    /**
     * <pre>
     * Denotes the maximum snapshot version at which the associated query view
     * contained no limbo documents.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
     */
    @Override
    public com.google.protobuf.Timestamp getLastLimboFreeSnapshotVersion() {
      return instance.getLastLimboFreeSnapshotVersion();
    }
    /**
     * <pre>
     * Denotes the maximum snapshot version at which the associated query view
     * contained no limbo documents.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
     */
    public Builder setLastLimboFreeSnapshotVersion(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setLastLimboFreeSnapshotVersion(value);
      return this;
      }
    /**
     * <pre>
     * Denotes the maximum snapshot version at which the associated query view
     * contained no limbo documents.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
     */
    public Builder setLastLimboFreeSnapshotVersion(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setLastLimboFreeSnapshotVersion(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     * Denotes the maximum snapshot version at which the associated query view
     * contained no limbo documents.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
     */
    public Builder mergeLastLimboFreeSnapshotVersion(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeLastLimboFreeSnapshotVersion(value);
      return this;
    }
    /**
     * <pre>
     * Denotes the maximum snapshot version at which the associated query view
     * contained no limbo documents.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp last_limbo_free_snapshot_version = 7;</code>
     */
    public Builder clearLastLimboFreeSnapshotVersion() {  copyOnWrite();
      instance.clearLastLimboFreeSnapshotVersion();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:firestore.client.Target)
  }
  @Override
  @SuppressWarnings({"unchecked", "fallthrough"})
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.firebase.firestore.proto.Target();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          Object[] objects = new Object[] {
            "targetType_",
            "targetTypeCase_",
            "targetId_",
            "snapshotVersion_",
            "resumeToken_",
            "lastListenSequenceNumber_",
            com.google.firestore.v1.Target.QueryTarget.class,
            com.google.firestore.v1.Target.DocumentsTarget.class,
            "lastLimboFreeSnapshotVersion_",
          };
          String info =
              "\u0000\u0007\u0001\u0000\u0001\u0007\u0007\u0000\u0000\u0000\u0001\u0004\u0002\t" +
              "\u0003\n\u0004\u0002\u0005<\u0000\u0006<\u0000\u0007\t";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<com.google.firebase.firestore.proto.Target> parser = PARSER;
        if (parser == null) {
          synchronized (com.google.firebase.firestore.proto.Target.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<com.google.firebase.firestore.proto.Target>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:firestore.client.Target)
  private static final com.google.firebase.firestore.proto.Target DEFAULT_INSTANCE;
  static {
    Target defaultInstance = new Target();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      Target.class, defaultInstance);
  }

  public static com.google.firebase.firestore.proto.Target getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<Target> PARSER;

  public static com.google.protobuf.Parser<Target> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

